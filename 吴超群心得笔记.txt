﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿1，﻿﻿二分法查找的扩展——对循环数组的查找
    因为是有序数组所以想到用二分法，但是因为经过向右位移，所以我只是简单的想到，查找头尾连接点，但是查找本身就会消耗很多资源，所以放弃了二分法。
    但是对于这题恰恰可以用二分法，不需要还原或者模拟原数组(开始模拟还原数组)，可以利用移动循环的特性使用二分法。
    开始判断数组中间的值
    如果小于查找值，正常应该在右边查找，这里我们先通过右边数组是否满足(a[mid]<=a[midmid]<=a[high]，开始我就是没想明白这个点，仔细想想确实可以用来判断)来判断右边是否是单调递增的，如果不是进右边的数组，(因为左边是单调递增的，又大于左边的最大值)，如果是，如果查找值大于右边最高点，说明不在右边范围内，则查找左边的数组。
   如果大于查找值，逻辑和上面相似。
   多次调用返回数组下标。
解法2：
        由观察坐标图，发现，当mid＞end 时，最高值在右边，左边单调递增。
当mid＜end且end＜star(有可能移动值为0，所以为了避免这种状况加一个判定)时最高值在左边，右边单调递增。
        剩下的内容和解法一类似。

2，有一个字符串，找到一个字符串中第一次出现两次的字符
        解法一：用HashMap存字符串的字符出现次数。
        解法二：用HashSet存字符串的字符，如果set的长度没有增长就说明重复了。
        解法三：如果一个字符串是ASC码的字符串，可以直接用byte数组，因为只是判断第二次出现，所以直接用二进制来记录出现次数，查询到的字符的出现次数如果是1就说明出现了两次。

3，LZW压缩算法，懒子王压缩算法
      通过为数据建立词典，达到压缩的效果。
例如，ABABBAACD，就4个字符，所以使用3位编码。
	建立词典，初始化词典。
先是A作为前缀，然后再取B作为后缀，现在是AB不认识，将它存入字典中，记为6，（下次遇到就认识了），前缀A输出，后缀B变成前缀，A进入，BA不认识，将它存入字典，记为7，然后B输出，前缀A变成后缀，B进入，变成AB，认识，记为6，A进入，6A，不认识，记为8（这里要用4为编码），然后就是把6输出。这样数据就变成，AB68。。。这样数据就短了，在传输到目标位置之后再建立词典，解析数据。
	如果词典code的位数太大，标记输出258，然后重新创建词典。
	在UCP框架中，code的最大位数和char相关，因为数据都是用StringBuffer存的。Code不能大于32767,如果大于就，重新创建词典。
4，Java反射机制在UCP中的运用
	利用Class.forName()获取class对象，利用class对象的newInstance()创建此Class对象所表示的类的一个新实例。
	Java.lang.reflect.Method.invoke(Object obj,Object...args)将创建的实例对象和参数组传入。
	利用表中的列名加set拼接方法名。

5,装饰设计模式
	利用传入不同的ClassName进行不同的装饰。
	
	public interface Sourceable {  
    	public void method();  
	}  
 
	public class Source implements Sourceable {  
  
  	  @Override  
   	 public void method() {  
        	System.out.println("the original method!");  
    	}  
	}  


	public class Decorator implements Sourceable {  
  
  	private Sourceable source;  
      	
	private Demo demo;

    	public Decorator(Sourceable source){  
        	super();  
        	s.source = source;  
    	}  
	
	public void init(String className){
		demo = (Demo)Class.forName(className).newIntstance();
	}

    	@Override  
    	public void method() {  
        	demo.beforMethod();
        	source.method();  
        	demo.afterMethod();  
   	 }  
	}  
	
	public interface Demo{
		public void beforMethod();
		public void afterMethod();
	}
	
	public class Demo2 implements Demo{
		@Override
		public void beforMethod(){
			System.out.println("方法开始前");
		}
		
		@Override
		public void afterMethod(){
			System.out.println("方法结束后");
		}	
	}

  6，不要迷失(摘自Java编程思想)
        在程序设计过程中时刻提醒自己对象是什么，需要将什么消息发给每一个对象。
        程序设计的整个过程可划分为4个阶段。
        0阶段：拟出一个计划
        1阶段：要制作什么
        2阶段：如何构建
        3阶段：开始构建
        4阶段：校订

7，KMP模式匹配算法
      建立next数组，用于在字符串和子串匹配到j，不符合时，回溯到子串的next[j]的位置。
        next数组记录子串中前缀字符串和后缀字符串匹配，进行到的前缀的位置加1。
	算法实现
	void getNext(String t, int [] next){
		int i,j;
		i=1;
		j=0;
		next[1]=0;
		while(i<T[0]){
			if(j==0||T[i]==T[j]){//对前缀和后缀进行匹配，比如next[6]=3，
				++i;         //表示6之前的5个字符的2个前缀和2个后缀相等，回溯时，从3开始。
				++j;
				next[i] = j;
			}else{
				j=next[j];//如果匹配进行到j，说明i之前的字符串的前缀和后缀是匹配的，匹配个数为j-1个，所以可以保证
			}		  //1到j-1的字符串的前缀（next[j]表示的区域）和i-j到i-1字符串的后缀（到next[j]表示的区域）是相匹配的。
					//即在1到i-1之间的区域的next[j]-1个字符的前后缀是相匹配的。所以j回溯到next[j]。
		}
	}
	int indexKMP(String S,String T,int pos){//pos表示开始匹配的位置
		int i = pos;
		int j = 1;
		int next[255];
		getNext(T,next);
		while(i<=S[0]&&j<=T[0]){
			if(j==0||S[i]==T[j]){//j==0表示i的位置移动到下一位，j重新回到1
				++i;++j;	
			}else{
				j=next[j];
			}
		}
		if(j>T[0]){
			return i-T[0];
		}else{
			return 0;
		}
			
	}

8，KMP模式匹配算法改进
	例如：
		字符串：a b c a m n ...			0 1 2 3 4 5 6
		子串 ： a b c a b x		next[]: 0 1 1 1 1 2 3
	当S[5]!=T[5] 回溯到 j=next[5]=2;
	但是这里可以不用回溯到2。
	因为S[5]!=T[5]且T[5]=T[2](子串的前5个中前缀和后缀匹配两个字符),所以S[5]一定不等于
	T[2],这里回溯到2是一个缺陷。
	
	修改方案:针对getNext()方法做出的修改
	void getNextval(...){
		
		if(j==0||T[i]==T[j]){
			++i;
			++j;
			if(T[i] != T[j]){	
				next[i] = j;
			}else{
				next[i] = next[j];
			}	
		}
	}
详解：
	（1）针对 if（T[i]!=T[j]） 如果S中当前字符不等于T中当前字符
	     且T中前缀第j字符和T中后缀当前字符不相等（上面代码中 T[i]!=T[j]），
	     说明S中当前字符有可能和T中前缀第j字符相等，可以回溯到j；
	（2）针对 next[i] = next[j]; 
	     例子：子串：abcadx...abcabx
	     循环到j且进入了这个判断，说明前缀j个字符和后缀j个字符相匹配。
	     按照之前的判断不能回溯到j。
	     这里前缀j（前j个字符）的前缀有next[j]-1个字符和前缀j的后缀相匹配，且
	     假设在j（前缀末）的位置与next[j]（前缀的前缀末）的位置字符不相等，（如果相等的话，还会继续往下
	     套，之前i执行到j位置时，已经处理过之类的问题了。）
	     以上面的例子为例，前缀abcabx和后缀abcabx相同，前缀的前缀ab == 前缀的后缀 ab，因为
	     前缀的c，和前缀的x不相等，映射到后缀的c和后缀的x也不相等，所以，前缀的c不等于后缀的x。
	     T[next[j]] != T[i] ,所以应该回溯到next[j]的位置，即得到next[i] = next[j]; 



9，Java线程池  Executors
      通过Executors可以获取不同的线程池，具体使用方法看API

10，java.lang.Runtime
     这个类中不仅可以设置给虚拟机用的关闭挂钩，还可以获取虚拟机的内存总量和剩余量，单位是B

11，里氏代换原则（详见Java与模式）
        父类可以做到的事，子类一定能做到。

12，依赖倒转原则(DIP)（详见Java与模式）
         底层依赖于高层，
         具体依赖于抽象。
         要求客户端依赖于抽象耦合。
         抽象耦合关系：发生在一个具体类和一个抽象类之间，使两个必须发生关系的类之间有最大的灵活性。
工厂方法模式，和模板模式都可以实现依赖倒转。
Java中new对象违反了依赖倒转原则，所以可以使用工厂方法模式，将变化的(对具体的依赖)封装到工厂方法中。


13，接口隔离原则（详见Java与模式）
        使用多个专用的接口比使用一个总的接口好。
        适配器模式：比如有三个不同的客户端，每个的需求都有些许不同。
       一个服务类实现了这三个接口。
       这时我们利用相应的接口引用就可以，将当前的客户端不需要的行为隐藏，而只暴露需要的行为。

14，备忘录模式（详见Java与模式）
        三个对象：一个发起人(它有需要备忘的状态)
         一个备忘录(用来保存发起人需要备忘的状态的类)
         一个负责人(负责将备忘录的集合保存起来)
       备忘录实现两个接口一个宽接口，一个窄接口。
        宽接口，中定义了可以提取，修改备忘录信息的方法，给发起人用，使它可以修改，提取备忘录的信息，仅仅对发起人开放。
        窄接口，中没有定义方法，是给负责人用的接口，只是让负责人可以保存备忘录。对其他类都开放。
这样实现仅仅对发起人开放呢？
        将备忘录设成发起人的内部类，并将备忘录的所有方法设置成私有的，提供一个获取备忘录实例对象的方法，在返回时将这个实例对象强转成窄接口的对象。
这样外部的类拿到备忘录对象就无法获取里面的任何消息了。

15，迪米特法则与依赖倒转的互补使用（详见Java与模式）
      迪米特法则：不和陌生人接触，尽量少的接触其他关系不紧密的类。
      这样做，可以降低耦合度，但是会造成很多小方法。
      利用引入一个抽象的陌生人，这样就不用和陌生人直接关联，通过接口类关联，这样具体的类修改也不会影响到调用陌生人接口的类。
    相关模式，门面模式，调停者模式。
    门面模式：当两个子系统交流过多时，可以建立一个门面类，让这两个子系统通过这个门面类来交流。从而降低系统的耦合度。
    调停者模式：当个一个中等规模的类群，它们之间存在较为复杂的调用关系，这时可以建立一个大家都认识的朋友，将他们相互之间的联系都交给调停者处理，使系统中有关的对象所引用的其他对象数目减少到最少。
使得一个对象与其同事的相互作用被这个对象与调停者对象的相互作用所取代。

16，广义迪米特法则（详见Java与模式）
      要求类，类方法，类的成员变量的访问权限尽量低。在方法中的变量的使用使用范围尽量小(有效范围可以是代码块的，不在设成方法的变量)
        谨慎使用Serializable序列化一个类，因为如果序列化一个类，在使用这个旧版本产生的序列化文件时，使用新版本的这个类来解析装载，这时可能会出错。而且影响所有使用这个序列化文件的模块。所以如果一个类要使用Serializable，那么这个类的内部结构就不能被修改，包括私有的方法和属性。
17，插值查找——有序表查找
         将二分法查找中的mid=1/2(low+high）
        改为mid=low+((key-a[low])/(a[high]-a[low]))*(high-low)
       在数据分布均匀时效率比二分法高，但是如果，数据分布十分不均匀，效率未必比二分法高。

18，平衡二叉树
        （详见大话数据结构）
19，快速排序的优化
     1，优化选取枢轴
	取多个点的中间值
     2，优化不必要的交换
        将关键轴存起来，在每次判断时，都直接赋值，不进行交换，最后再把关键轴的值付给最后的值。
     3，优化数组时的排序方案
        在数组长度较小时可以用直接插入排序。
     4，优化递归操作
        可以省掉一部分递归，缩减堆栈深度。
	void QSort1(SqList *L,int low ,int high){
		...

		while(low<high){   //将原来的if改为while
			pivot = Partition1(L,low,high);
			
			QSort1(L,low,pivot-1);
			low = pivot+1;	//利用循环进行另一部分的循环，尾递归
		}
	}
	QSort1(L,low,pivot-1) 进行low到pivot-1部分的循环，while（low<high）进行pivot+1到high的循环

20，简单工厂模式，工厂方法模式，抽象工厂模式
	简单工厂模式：一般的工厂模式
	工厂方法模式：用一个抽象的工厂类同意工厂，在客户端创建不同的工厂来生产对象，这个符合开闭原则（对扩展开放，对修改关闭）
	抽象工厂模式：适用于，有多个种类的产品，产品有多个等级，一个工厂的一个工厂方法对应一个产品，工厂类的多少，
	 	      对应产品等级的多少，工厂中方法的多少对应产品种类的多少。

21，Java多线程——原子性（Java多线程编程）
       大部分的引用操作是原子的，是不可分割的。
     如：n=23这样的操作是不可分割的。
    但是long ，double的指定引用操作并非不可分割，大部分的Java执行环境还是将long，double当作原子的操作来实现。
    如：longField=123L
            另一个线程执行：
            longField=456L
          这时无法保证结果是123或456，也许是0或者31415926。

22，ThreadPoolExecutor线程池
    这个类初始化时，可以传入RejectedExecutionHandler用来当超出线程范围和队列容量而使执行被阻塞时使用的处理程序。
在UCP中RejectedExecutionHandler以内部类的形式被继承。

23，Java堆内存（Java优化编程）
      堆内存中分新对象区和老对象区
      新对象区又分：Eden区，from区，to区

24，关于毕设
   创建一个Map <SocketTank>socketMap  将连接到的socket存入这个Map中，当玩家连接上时就将这个套接字保存在套接字注册表中，在SocketTank中保存有输入流和输出流。在主机想要返回数据时，使用这个输出流来为客户端返回数据
   关于数据的发送，设置线程池上限，从线程池获取线程用于发送数据，一个玩家对应一个，发送双缓冲队列
需要发送的数据和SocketTank放一起，
如果SocketTank如果SocketTank正在线程中发送数据，那么直接把数据放到SocketTank的数据堆中。SocketTank的发送数据和提取数据堆的操作中加同步，保证同一时刻只有一个线程在发送数据，修改发送数据堆。
再建立一个线程监控接收数据，当接收线程接收到数据时，唤醒监控接收数据线程，如果把接收数据的数据取出，扎堆，再分别发给SocketTank
主机和其他玩家的机器的区别在于接收数据的连接和发送数据的连接数量不同，主机有其他玩家包括自己的socket连接
在Game继承的类中增加方法，将玩家的动作编译成输出数据，存入要发送的数据堆。
有n个人进行游戏，有n和连接，
主机要将数据发送给链接注册表中的所有链接。一共n个连接。
非主机要将数据发送给链接注册表中的所有链接，只有一个主机连接。
主机和其他机器都是接收所有数据。
生产出来的坦克都必须保存在Map中，这样方便分析数据时控制。key用坦克的ID，一个用户不一定只对应一个坦克，主机连接中可能发送中立坦克的信息。

25，队列的读写互斥
    在访问队列时，需要互斥吗？这将依赖于队列的数据结构实现，如果使用STL中的vector，由于vector会动态增长。因此要做互斥保护。如果使用循环队列，那么读取数据线程拥有读取指针，写入数据线程拥有写入指针，各自将访问队列中不同位置上的数据，因此不用进行互斥保护。

26，volatile关键字
Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
实例：
private volatie int a;
一般在什么情况下使用volatie？
意思是当前线程使用该成员变量，另一线程会改变这个成员变量？
回答
对。比如类中有成员int x, 下面两句连着的：
x=5;
x++;
如果单线程的话执行到第二句x的值一定是6，但是如果两个线程都可以访问此类的同一个对象，那在执行完第一句后第二句前，说不定x就给改成其他值了，x++的结果就不一定是6了。这种情况下应该将x声明为volatile，否则编译器也许会作出你意想不到的优化，使得编译后的程序非你所愿。比如说编译器看见这两句，你又不声明x为volatile，那编译器就觉得第二句后x一定是6，它就直接把这两句优化成x=6了。

27，关于队列Queue
     阻塞队列(BlockingQueue)：适用于消费者生产者模式，当消费者取数据时没有数据就发生阻塞，生产者存入数据时队列满了也阻塞。经典实现，ArrayBlockingQueue有界阻塞数组实现的队列(具体看API)。
    非阻塞队列：在取不到数据时返回null，经典实现，
ConcurrentLinkedQeue链接节点，无界，线程安全的队列。
算法实现入队，
public boolean offer(E e) {
    if (e == null) throw new NullPointerException();
    //入队前，创建一个入队节点
    Node<E> n = new Node<E>(e);
    retry:
    //死循环，入队不成功反复入队。
    for (;;) {
        //创建一个指向tail节点的引用
        Node<E> t = tail;
        //p用来表示队列的尾节点，默认情况下等于tail节点。
        Node<E> p = t;
        for (int hops = 0; ; hops++) {
        //获得p节点的下一个节点。
            Node<E> next = succ(p);
        //next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点
            if (next != null) {
               //循环了两次及其以上，并且当前节点还是不等于尾节点
                if (hops > HOPS && t != tail)
                    continue retry; 
                p = next;
            } 
            //如果p是尾节点，则设置p节点的next节点为入队节点。
            else if (p.casNext(null, n)) {
              //如果tail节点有大于等于1个next节点，则将入队节点设置成tair节点，更新失败了也
没关系，因为失败了表示有其他线程成功更新了tair节点。
                if (hops >= HOPS)
                    casTail(t, n); // 更新tail节点，允许失败
                return true;  
            } 
           // p有next节点,表示p的next节点是尾节点，则重新设置p节点
            else {
                p = succ(p);
            }
        }
    }
}
从源代码角度来看整个入队过程主要做二件事情。第一是定位出尾节点，第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。

第一步定位尾节点。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加第一次节点，所以需要返回head节点。获取p节点的next节点代码如下

final Node<E> succ(Node<E> p) {
         Node<E> next = p.getNext();
         return (p == next) ? head : next;
     }
第二步设置入队节点为尾节点。p.casNext(null, n)方法用于将入队节点设置为当前队列尾节点的next节点，p如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。

hops的设计意图。上面分析过对于先进先出的队列入队所要做的事情就是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么我用以下方式来实现行不行？

public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        Node<E> n = new Node<E>(e);
        for (;;) {
            Node<E> t = tail;
            if (t.casNext(null, n) && casTail(t, n)) {
                return true;
            }
        }
    }
让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当 tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。

private static final int HOPS = 1;
还有一点需要注意的是入队方法永远返回true，所以不要通过返回值判断入队是否成功。
算法实现出队，
出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化。
并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。让我们再通过源码来深入分析下出队过程。

public E poll() {
    Node<E> h = head;
   // p表示头节点，需要出队的节点
    Node<E> p = h;
    for (int hops = 0;; hops++) {
        // 获取p节点的元素
        E item = p.getItem();
        // 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,如果成功则返回p节点的元素。
        if (item != null && p.casItem(item, null)) {
            if (hops >= HOPS) {
                //将p节点下一个节点设置成head节点
                Node<E> q = p.getNext();
                updateHead(h, (q != null) ? q : p);
            }
            return item;
        }
        // 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。那么获取p节点的下一个节点 
        Node<> next = succ(p);
        // 如果p的下一个节点也为空，说明这个队列已经空了
        if (next == null) {
          // 更新头节点。
            updateHead(h, p);
            break;
        }
        // 如果下一个元素不为空，则将头节点的下一个节点设置成头节点
        p = next;
    }
    return null;
}
首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。

28，Java队列类
 如果这一个队列，先写一个接口，加上范型。
如果是有界的final items[]  如果多线程队头和队尾要加volatile关键字，加上ReentrantLock锁用来代替synch...关键字，用lock.newCondition()获取Condition对象，用来代替object.wait()和notify()。

29，利用赫夫曼树进行多级比较
  将学生的成绩分为优秀，良，中，及格，不及格。通过建立赫夫曼树，假设良和中的人最多。
        先比较小于80的，在比较小70和小于90的，再在下一个层中比较。
      这样比传统的比较方法少很多比较次数。

30，最短路径问题——迪杰斯特拉(Dijkstra)算法
	（详见大话数据结构）
        时间复杂度是O(n平方)
	for(v = 1; v<G.numVertexes;v++){
		min = INTMAX;  //int最大值
		//找到除已经确定的到V0为最短路径的点外，到V0最近的点，因为这个点到
		//V0的距离是最短的，所以没有可能通过其他的点绕路找到更短的距离。
		for(w = 0; w<G.numVertexes;w++){
			if(!final[w] && (*D)[w]<min){
				k = w;
				min = (*D)[w];
			}
		}
		//将找到的最近的点，设置成V0到Vk的最短路径。
		//因为V0到K点的距离是最短的，所以没有可能通过其他可以到Vk的点
		//来找到更短的距离
		final[k] = 1;
		for(w = 0;w<G.numVertexes;w++){
			
			if(!final[w] && (min+G.matirx[k][w])){
				//通过找到的K点，到达其他的点，查看是否比已知的
				//到达W点的距离更短
				(*D)[w] = min + G.matirx[k][w];
				(*P)[w] = k;
			}
			
		}
		
	}
31，最短路径问题——弗洛伊德(Floyd)算法（详见大话数据结构）
      时间复杂度O(n立方)计算得到每个点之间的最短路径。
	int v,w,k;
	for(v = 0 ;v<G.numVertexes;v++){
		
		for(w =0;w<G.numVertexes;++w){
			(*D)[v][w] = G.matirx[v][w];//对应点到点的权值（距离）
			(*P)[v][w] = w;	//记录v到w最短路径要经过的第一个点
		}
	}
	
	for(k = 0;k<G.numVertexes;++k){
		
		for(v = 0;v<G.numVertexes;++v){
			for(w = 0;w<G.numVertexes;++w){
				if((*D)[v][w]>(*D)[v][k]+(*D)[k][w]){
					//更新v到w的最短距离
					(*D)[v][w] = (*D)[v][k]+(*D)[k][w];
					//因为v到w通过k中转，所以v到w经过的第一个点
					//就是v到k经过的第一个点
					(*P)[v][w] = (*P)[v][k];
				}
			}
		}
	}
32，归并排序的非递归算法（详见大话数据结构）
      归并排序是稳定的排序算法，时间复杂度O（n*logN）空间复杂度O（n+logN）
      利用了类似二叉树的结构。
      因为递归算法会消耗额外的栈空间log2N 和一些时间，所以一般情况我们避免使用
      递归的方法。
      归并的非递归方法，将数组分为长度为1的小段，然后相邻的小段分别
      归并，第二次归并时，小段的长度为k*2，即2，然后依次类推，如果没有
      满2个k但是有一个就Merge(SR,TR,i,i+s-1,n)将剩下的进行归并
     如果没有一个就直接保存在TR中。
	int k = 1;//这里的k开始是1，表示将数组分成k长度的小段。
	while(k<L->length){
		MergePass(L->r,TR,k,L->length);
		k = 2*k;//因为是两两归并，所以第二次的长度就是k*2=2
		MergePass(TR,L->r,k,L->length);
		k = 2*k;//这个是归并了两次都变成4
	}
	//s表示分成的小段的长度，开始是1，模拟了归并的递归将数组分成长度为1的小段
	//的过程
	void MergePass(int SR[],int TR[],int s,int n){
		int i = 1;
		int j ;
		while(i<=n-2*s+1){
			Merge(SR,TR,i,i+s-1,i+2*s-1);
			i = i+2*s;
		}
		if(i<n-s+1){
			Merge(SR,TR,i,i+s-1,n);
		}else{
			for(j=i;j<= n;j++){
				TR[j] = SR[j];
			}
		}
	}
	//归并SR中i到m，m+1到n的数组，归并到TR中
	void Merge(int SR[],int TR[],int i,int m,int n){
		
		int j,k,l;
		for(j=m+1,k=i;i<=m && j<=n;k++){
			if(SR[i]<SR[j]){
				TR[k] = SR[i++];
			}else{
				TR[kvoid] = SR[j++];
			}
		}
		if(i<=m){
			for(l = 0;l<=m-i;l++){
				TR[K+1] = SR[i+1];
			}
		}
		if(j<=n){
			for(l=0;l<=n-j;l++){
				TR[k+1] = SR[j+1];
			}
		}
	}	
33，堆排序
     不稳定的排序算法，利用了类似二叉树的结构。
	对顺序表L进行堆排序
	void HeapSort(SqList *L){
		int i;
		for(i=L->length/2;i>0;i--){	//把L中的r构建成一个大顶堆
			HeapAdjust(L,i,L->length);	
		}
		for(i=L->length;i>1;i--){
			swap(L,1,i);	//将堆顶记录和当前未经排序的子序列的最后一个记录交换；
			HeapAjust(L,1,i-1);//将L->r[1..i-1]重新调整为大顶堆	
		}
	}
	
	void HeapAdjust(SqList *L,int s,int m){
		int temp,j;
		temp=L->r[s];
		for(j=2*s;j<=m;j*=2){//沿关键字较大的孩子节点向下筛选
			if(j<m && L->r[j] < L->r[j+1]){
				++j;	//j为关键字中较大的记录的下标
			}
			if(temp >= L->r[j]){
				break;  //因为堆顶没有改变，所以不用再次循环。
			}
			L->r[s] = L->r[j];
			s = j;	//因为j改变了，所以对以j为堆顶的堆进行之前的操作。
		}
		L->r[s] = temp;	
	}

34，单例模式（详见Java与模式，215页）
	懒汉式：等到用时才进行对象的实例化，要对获取单例对象的方法进行同步处理。
	饿汉式：类加载时就进行实例化，不用对获取单例对象的方法进行同步处理。
	登记式单例模式：对实例化的对象进行保存，由父类创建子类的对象，但是这样做的话子类中的构造函数就必须是公有的，父类中的构造方法是保护类型的。

35，去哪儿最后一题

36，Runtime可以执行外部命令
     打开note.exe程序
      Runtime.getRuntime().exec("note.exe");
还可以使用DOS命令行的形式打开，doc文档

37，Java优化——创建对象的关键规则
      避免在循环中创建对象
     避免使用过于复杂的继承关系
      使用本地的引用比使用类中的引用好
      尽量及时使用对象

38，引用(作用参见API)
    强引用
    软引用：SoftReference
    弱引用
    虚引用

39，平衡二叉树与红黑树的比较(详见大话数据结构)
     红黑树不是严格的平衡，所有查找的性能略低于平衡二叉树
    红黑树的插入，最多进行三次旋转，有时要递归维护color，插入的时间复杂度，主要来自开始寻找插入位置的O(logn)
     AVL树的插入要进行递归的判断，维护某一条支线的BF，旋转的次数最多2次，最少没有。
    红黑树的插入可以不用递归实现，不是每次都维护color，
    AVL树几乎每次都要进行多次递归，并且维护bf。
    所以红黑树的插入比AVL树快点，AVL树因为是严格的平衡，所以查找比红黑树快一点。

40，B树，B+树(详见大话数据结构)
     适用于内存和外存交换数据频繁的时候，作用类似于分块索引。
两树区别，B+树中所有叶子节点保存所有数据，
41，索引
    稠密索引：为每一个数据建立一个索引，
对索引进行排序，查找时就可以使用折半查找，差值查找，斐波那契查找，查找，时间复杂度，O(logn)
    分块索引：将数据按照一定的规律分块，块间有序，块内无序。我们保存一个，块信息的有序表，利用有序查找的方法查找对应的块，然后再在块中进行查找。
    倒排索引：基础搜索技术，将一句话，分解成多个单词，将这些单词存入数据库，记录这些单词的出处，当有人搜索这些单词时，就去数据库中找到这个单词，查看这个单词的出处列表，将出处显示给客户。

42，拓扑排序
      在一个工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称之为AOV网。
        在平时，许多工程中都用到AOV网，AOV网是无回路的，将这个AOV网的顶点按照依赖关系先后输出，得到的序列称之为拓扑序列，而生成这个序列的过程就是，拓扑排序。
        基本思路：找到图中入度为0的点，将它存入栈中，每次从栈中取出点，遍历这个点的临接点，将临接点的入度减一，如果临接点的入度为0就将它存入栈，循环直到栈为空。可以查看输出的点数是否和图的点数相同，不同，说明有环。

43，建造模式
       有一些产品在使用之前一定要先有一些基本的属性，这些属性的值可能是多样的，这时我们可以使用一个建造者专门的负责给产品的赋于属性。
    Builder，建造者的抽象父类。
    ConcreteBuilder，建造者的具体类，
     在这个具体类中可以分步为产品建造零件，
    还应该有一个返回产品的方法。
   产品类，
    使用者类。
    导演者，使用者把操作具体建造者的任务交给导演者，创建具体建造者对象的任务应该由使用者执行，这样降低导演者和建造者的耦合度，导演者可以操作多种具体建造者

44，可以将频繁调用的属性存到本地的栈内存，而不是通过引用反复调用geter方法来获取。
    如：Demo.getCount()
            int i = Demo.getCount()的区别就在于一个存到了栈内存，一个还在堆中。
      测试两者的效率差，时间单位：毫秒
进行一百万次count = demo.getCount()用时281
进行一百万次count = num用时125
因为反复调用方法耗时较多。

45，原型模式
       原型模式一共有三个角色
       客户：客户提出创建对象的请求
       抽象原型：一个抽象角色，实现Cloneable接口。
       具体原型：被复制的对象，实现抽象原型接口。
       对象通过调用clone方法复制自身。
       复制自身分为深复制和浅复制。
       浅复制：复制对象的所有变量都含有与原来的对象相同的值，而所有其他对象的引用都仍然指向原来的对象。
       深复制：除了浅复制所做的事，深复制还将复制对象的引用所指向的对象，进行间接复制，复制深度可以自己定。
      在深度复制时可以使用串行化和并行化来实现，必须保证类实现Serializable接口
在不需要串行化的连接对象上加transient关键字瞬间值。
具体串行化并行化方法，java与模式328P

46，快速排序的优化，结合API中对相同数据时的优化

47，java API中对对象使用归并排序，当数组长度小于7时，使用插入排序。

48，适配器模式
    用于转换状态。
    类适配器：用于类的适配器。
    对象适配器：用于对象状态转换的适配器。
    目标角色：所期待得到的接口。
     源：需要被转换的接口。
    适配器：把源接口转换为目标接口。
    适配器模式和装饰模式的区别，适配器模式可以改变接口的类型

49，缺省适配模式
     当不需要实现一个接口的全部方法时可以使用，建立一个抽象的适配器，平庸的实现接口的方法，让要使用这个接口的实体类继承这个平庸的实现。
      缺省适配器模式在监听键盘事件和鼠标事件上都有应用。

50，合成模式
     安全式合成模式：
     抽象构件：一个抽象角色，它给参加组合的对象定义出公共的接口及默认的行为，没有给出对集合操作的方法。
     树叶构件角色：树叶对象是没有下级子对象的对象，只是实现抽象构件要求的方法，不实现集合的操作方法，没有保存的集合。
     树枝构件角色：有下级对象，里面存在一个集合保存下级对象，提供对下级对象的增删改操作。
     透明式：
     抽象构件：给出所有方法，包括对集合的操作方法。
     树叶构件：对集合操作方法进行平庸实现，其他正常实现。
     树枝构件：实现抽象构件的所有方法。

51，在Java中使用final可以提高代码的运行效率，因为在编译过程中将final标记的方法，写入到调用处，final方法是不变的，所以可以直接带入，如同C++中的内联方法。

52，java中流处理器可以分为
    原始流处理器：接收一个byte对象，String，文件等不同类型的流源对象。
    链接流处理器：接收另一个流对象，并对其进行功能扩展。

53，代理模式
     为两个相互间不相匹配的对象，建立代理类，使之通过代理类通信。
   
54，循环中的注意事项
     1，在循环中复制数组，最好用system.arraycopy()，这个方法效率比循环复制效率高，一个方法是本地方法。
     2，避免在循环中调用方法，那样的代价高。
     3，避免在循环中使用数组的存取，可以使用临时变量，那样的效率更快些。
     4，在没有使用JIT或HotSpot虚拟机时，尽量使用0作为判断条件，比用其他的数快些。在xp  jdk1.6下测试没有区别。
      5，避免在判断条件中使用方法返回值，那样反复调用方法，会影响效率。
    6，避免在循环中使用try  catch代码块，主要出于效率考虑。
    7，在使用多重循环时，尽量把循环长度长的循环放在里面，这样减少循环切换的次数。
     8，当if  else在多次的循环中时，尽量将if  else放在循环外面，减少if判断的次数，如果循环次数较少，可以按照简洁的方式来。

55，Vector与ArrayList的区别
     Vector有一个增长因子，在数组扩充的时候可以根据增长因子扩充，要是没有设置，则翻倍扩充，是线程安全的。数据数组不是瞬时值
      ArrayList 在数组扩充的时候增长50％，线程不安全，数据数组为瞬时值。
      在数组扩充时都有一个oldData数组引用指向旧的数组对象。
